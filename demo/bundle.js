/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js"
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pkg_lindera_wasm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../pkg/lindera_wasm.js */ \"../pkg/lindera_wasm.js\");\n\n\n// Initialize the tokenizer\nlet tokenizer = null;\n\n// Initialize WASM module first\n(0,_pkg_lindera_wasm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().then(() => {\n    // Show the version in the title\n    try {\n        const version = (0,_pkg_lindera_wasm_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)();\n        document.title = `Lindera WASM v${version}`;\n        document.getElementById('title').textContent = `Lindera WASM v${version}`;\n    } catch (e) {\n        console.error(\"Failed to get version:\", e);\n    }\n\n    try {\n        // Option 1: Using TokenizerBuilder (WASM style, snake_case is also supported)\n        let builder = new _pkg_lindera_wasm_js__WEBPACK_IMPORTED_MODULE_0__.TokenizerBuilder();\n        builder.setDictionary(\"embedded://ipadic\");\n        builder.setMode(\"normal\");\n        tokenizer = builder.build();\n\n        // Option 2: Using loadDictionary and Tokenizer constructor (Python style)\n        /*\n        const dict = loadDictionary(\"embedded://ipadic\");\n        tokenizer = new Tokenizer(dict, \"normal\");\n        */\n\n        console.log(\"Tokenizer is ready.\");\n    } catch (e) {\n        // Handle the error\n        console.error(\"Failed to create Tokenizer:\", e);\n    }\n}).catch(e => {\n    console.error(\"Failed to initialize WASM module:\", e);\n});\n\n// Add an event listener to the \"runButton\" element\ndocument.getElementById('runButton').addEventListener('click', () => {\n    // If the tokenizer is not initialized yet, display an error message\n    if (!tokenizer) {\n        console.error(\"Tokenizer is not initialized yet.\");\n        return;\n    }\n\n    // Get the input text from the \"inputText\" element\n    const inputText = document.getElementById('inputText').value;\n\n    // Tokenize the input text\n    const tokens = tokenizer.tokenize(inputText);\n\n    // Get the \"resultList\" element\n    const resultList = document.getElementById('resultList');\n\n    // Clear the previous results\n    resultList.innerHTML = '';\n\n    // Create table for results\n    const table = document.createElement('table');\n    table.className = 'token-table';\n    table.innerHTML = `\n        <thead>\n            <tr>\n                <th>Surface</th>\n                <th>Position</th>\n                <th>Details</th>\n            </tr>\n        </thead>\n        <tbody></tbody>\n    `;\n    const tbody = table.querySelector('tbody');\n\n    tokens.forEach((token, index) => {\n        const tr = document.createElement('tr');\n\n        // Accessing properties directly from Token object\n        const surface = token.surface;\n        const position = token.position;\n        // Using getDetail(index) method\n        const detail = token.getDetail(0) || '*';\n        const allDetails = token.details.join(', ');\n\n        tr.innerHTML = `\n            <td><strong>${surface}</strong></td>\n            <td>${position}</td>\n            <td><small>${allDetails}</small></td>\n        `;\n        tbody.appendChild(tr);\n    });\n\n    resultList.appendChild(table);\n});\n\n\n//# sourceURL=webpack://lindera-wasm-example/./src/index.js?\n}");

/***/ },

/***/ "../pkg/lindera_wasm_bg.wasm"
/*!***********************************!*\
  !*** ../pkg/lindera_wasm_bg.wasm ***!
  \***********************************/
(module, __unused_webpack_exports, __webpack_require__) {

eval("{module.exports = __webpack_require__.p + \"a25063a6f27878e8736f.wasm\";\n\n//# sourceURL=webpack://lindera-wasm-example/../pkg/lindera_wasm_bg.wasm?\n}");

/***/ },

/***/ "../pkg/lindera_wasm.js"
/*!******************************!*\
  !*** ../pkg/lindera_wasm.js ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompressionAlgorithm: () => (/* binding */ CompressionAlgorithm),\n/* harmony export */   Dictionary: () => (/* binding */ Dictionary),\n/* harmony export */   FieldDefinition: () => (/* binding */ FieldDefinition),\n/* harmony export */   FieldType: () => (/* binding */ FieldType),\n/* harmony export */   JsDictionary: () => (/* binding */ JsDictionary),\n/* harmony export */   JsFieldDefinition: () => (/* binding */ JsFieldDefinition),\n/* harmony export */   JsLinderaError: () => (/* binding */ JsLinderaError),\n/* harmony export */   JsMetadata: () => (/* binding */ JsMetadata),\n/* harmony export */   JsPenalty: () => (/* binding */ JsPenalty),\n/* harmony export */   JsSchema: () => (/* binding */ JsSchema),\n/* harmony export */   LinderaError: () => (/* binding */ LinderaError),\n/* harmony export */   Metadata: () => (/* binding */ Metadata),\n/* harmony export */   Mode: () => (/* binding */ Mode),\n/* harmony export */   Penalty: () => (/* binding */ Penalty),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Segmenter: () => (/* binding */ Segmenter),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   Tokenizer: () => (/* binding */ Tokenizer),\n/* harmony export */   TokenizerBuilder: () => (/* binding */ TokenizerBuilder),\n/* harmony export */   UserDictionary: () => (/* binding */ UserDictionary),\n/* harmony export */   buildDictionary: () => (/* binding */ buildDictionary),\n/* harmony export */   buildUserDictionary: () => (/* binding */ buildUserDictionary),\n/* harmony export */   build_dictionary: () => (/* binding */ build_dictionary),\n/* harmony export */   build_user_dictionary: () => (/* binding */ build_user_dictionary),\n/* harmony export */   \"default\": () => (/* binding */ __wbg_init),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   initSync: () => (/* binding */ initSync),\n/* harmony export */   loadDictionary: () => (/* binding */ loadDictionary),\n/* harmony export */   loadUserDictionary: () => (/* binding */ loadUserDictionary),\n/* harmony export */   load_dictionary: () => (/* binding */ load_dictionary),\n/* harmony export */   load_user_dictionary: () => (/* binding */ load_user_dictionary),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* @ts-self-types=\"./lindera_wasm.d.ts\" */\n\n/**\n * Compression algorithm for dictionary data.\n * @enum {0 | 1 | 2 | 3}\n */\nconst CompressionAlgorithm = Object.freeze({\n    Deflate: 0, \"0\": \"Deflate\",\n    Zlib: 1, \"1\": \"Zlib\",\n    Gzip: 2, \"2\": \"Gzip\",\n    Raw: 3, \"3\": \"Raw\",\n});\n\n/**\n * A morphological analysis dictionary.\n */\nclass Dictionary {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Dictionary.prototype);\n        obj.__wbg_ptr = ptr;\n        DictionaryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        DictionaryFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_dictionary_free(ptr, 0);\n    }\n}\nif (Symbol.dispose) Dictionary.prototype[Symbol.dispose] = Dictionary.prototype.free;\n\n/**\n * Field definition in dictionary schema.\n */\nclass FieldDefinition {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FieldDefinition.prototype);\n        obj.__wbg_ptr = ptr;\n        FieldDefinitionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        FieldDefinitionFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_fielddefinition_free(ptr, 0);\n    }\n    /**\n     * @returns {string | undefined}\n     */\n    get description() {\n        const ret = wasm.__wbg_get_fielddefinition_description(this.__wbg_ptr);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * @returns {FieldType}\n     */\n    get field_type() {\n        const ret = wasm.__wbg_get_fielddefinition_field_type(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get index() {\n        const ret = wasm.__wbg_get_fielddefinition_index(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {string}\n     */\n    get name() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_fielddefinition_name(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string | null} [arg0]\n     */\n    set description(arg0) {\n        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_fielddefinition_description(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @param {FieldType} arg0\n     */\n    set field_type(arg0) {\n        wasm.__wbg_set_fielddefinition_field_type(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @param {number} arg0\n     */\n    set index(arg0) {\n        wasm.__wbg_set_fielddefinition_index(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @param {string} arg0\n     */\n    set name(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_fielddefinition_name(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) FieldDefinition.prototype[Symbol.dispose] = FieldDefinition.prototype.free;\n\n/**\n * Field type in dictionary schema.\n * @enum {0 | 1 | 2 | 3 | 4}\n */\nconst FieldType = Object.freeze({\n    /**\n     * Surface form (word text)\n     */\n    Surface: 0, \"0\": \"Surface\",\n    /**\n     * Left context ID for morphological analysis\n     */\n    LeftContextId: 1, \"1\": \"LeftContextId\",\n    /**\n     * Right context ID for morphological analysis\n     */\n    RightContextId: 2, \"2\": \"RightContextId\",\n    /**\n     * Word cost (used in path selection)\n     */\n    Cost: 3, \"3\": \"Cost\",\n    /**\n     * Custom field (morphological features)\n     */\n    Custom: 4, \"4\": \"Custom\",\n});\n\nclass JsDictionary {\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsDictionaryFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsdictionary_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get encoding() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.jsdictionary_encoding(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Metadata}\n     */\n    get metadata() {\n        const ret = wasm.jsdictionary_metadata(this.__wbg_ptr);\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    get name() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.jsdictionary_name(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) JsDictionary.prototype[Symbol.dispose] = JsDictionary.prototype.free;\n\nclass JsFieldDefinition {\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsFieldDefinitionFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsfielddefinition_free(ptr, 0);\n    }\n    /**\n     * @param {number} index\n     * @param {string} name\n     * @param {FieldType} field_type\n     * @param {string | null} [description]\n     */\n    constructor(index, name, field_type, description) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(description) ? 0 : passStringToWasm0(description, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        const ret = wasm.jsfielddefinition_new(index, ptr0, len0, field_type, ptr1, len1);\n        return FieldDefinition.__wrap(ret);\n    }\n}\nif (Symbol.dispose) JsFieldDefinition.prototype[Symbol.dispose] = JsFieldDefinition.prototype.free;\n\nclass JsLinderaError {\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsLinderaErrorFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jslinderaerror_free(ptr, 0);\n    }\n    /**\n     * @param {string} message\n     */\n    constructor(message) {\n        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.jslinderaerror_new(ptr0, len0);\n        return LinderaError.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.jslinderaerror_toString(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\nif (Symbol.dispose) JsLinderaError.prototype[Symbol.dispose] = JsLinderaError.prototype.free;\n\nclass JsMetadata {\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsMetadataFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsmetadata_free(ptr, 0);\n    }\n    /**\n     * @returns {CompressionAlgorithm}\n     */\n    get compress_algorithm() {\n        const ret = wasm.jsmetadata_compress_algorithm(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Metadata}\n     */\n    static createDefault() {\n        const ret = wasm.jsmetadata_createDefault();\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @returns {Schema}\n     */\n    get dictionary_schema() {\n        const ret = wasm.jsmetadata_dictionary_schema(this.__wbg_ptr);\n        return Schema.__wrap(ret);\n    }\n    /**\n     * @returns {string}\n     */\n    get encoding() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.jsmetadata_encoding(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {string}\n     */\n    get name() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.jsmetadata_name(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string | null} [name]\n     * @param {string | null} [encoding]\n     * @param {CompressionAlgorithm | null} [compress_algorithm]\n     */\n    constructor(name, encoding, compress_algorithm) {\n        var ptr0 = isLikeNone(name) ? 0 : passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(encoding) ? 0 : passStringToWasm0(encoding, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        const ret = wasm.jsmetadata_new(ptr0, len0, ptr1, len1, isLikeNone(compress_algorithm) ? 4 : compress_algorithm);\n        return Metadata.__wrap(ret);\n    }\n    /**\n     * @param {CompressionAlgorithm} algorithm\n     */\n    set compress_algorithm(algorithm) {\n        wasm.jsmetadata_set_compress_algorithm(this.__wbg_ptr, algorithm);\n    }\n    /**\n     * @param {Schema} schema\n     */\n    set dictionary_schema(schema) {\n        _assertClass(schema, Schema);\n        var ptr0 = schema.__destroy_into_raw();\n        wasm.jsmetadata_set_dictionary_schema(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * @param {string} encoding\n     */\n    set encoding(encoding) {\n        const ptr0 = passStringToWasm0(encoding, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.jsmetadata_set_encoding(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @param {string} name\n     */\n    set name(name) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.jsmetadata_set_name(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * @param {Schema} schema\n     */\n    set user_dictionary_schema(schema) {\n        _assertClass(schema, Schema);\n        var ptr0 = schema.__destroy_into_raw();\n        wasm.jsmetadata_set_user_dictionary_schema(this.__wbg_ptr, ptr0);\n    }\n    /**\n     * @returns {Schema}\n     */\n    get user_dictionary_schema() {\n        const ret = wasm.jsmetadata_user_dictionary_schema(this.__wbg_ptr);\n        return Schema.__wrap(ret);\n    }\n}\nif (Symbol.dispose) JsMetadata.prototype[Symbol.dispose] = JsMetadata.prototype.free;\n\nclass JsPenalty {\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsPenaltyFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jspenalty_free(ptr, 0);\n    }\n    /**\n     * @param {number | null} [kanji_penalty_length_threshold]\n     * @param {number | null} [kanji_penalty_length_penalty]\n     * @param {number | null} [other_penalty_length_threshold]\n     * @param {number | null} [other_penalty_length_penalty]\n     */\n    constructor(kanji_penalty_length_threshold, kanji_penalty_length_penalty, other_penalty_length_threshold, other_penalty_length_penalty) {\n        const ret = wasm.jspenalty_new(isLikeNone(kanji_penalty_length_threshold) ? 0x100000001 : (kanji_penalty_length_threshold) >>> 0, isLikeNone(kanji_penalty_length_penalty) ? 0x100000001 : (kanji_penalty_length_penalty) >> 0, isLikeNone(other_penalty_length_threshold) ? 0x100000001 : (other_penalty_length_threshold) >>> 0, isLikeNone(other_penalty_length_penalty) ? 0x100000001 : (other_penalty_length_penalty) >> 0);\n        return Penalty.__wrap(ret);\n    }\n}\nif (Symbol.dispose) JsPenalty.prototype[Symbol.dispose] = JsPenalty.prototype.free;\n\nclass JsSchema {\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        JsSchemaFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsschema_free(ptr, 0);\n    }\n    /**\n     * @returns {Schema}\n     */\n    static create_default() {\n        const ret = wasm.jsschema_create_default();\n        return Schema.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    field_count() {\n        const ret = wasm.jsschema_field_count(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {string[]}\n     */\n    get_all_fields() {\n        const ret = wasm.jsschema_get_all_fields(this.__wbg_ptr);\n        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        return v1;\n    }\n    /**\n     * @returns {string[]}\n     */\n    get_custom_fields() {\n        const ret = wasm.jsschema_get_custom_fields(this.__wbg_ptr);\n        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        return v1;\n    }\n    /**\n     * @param {string} name\n     * @returns {FieldDefinition | undefined}\n     */\n    get_field_by_name(name) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.jsschema_get_field_by_name(this.__wbg_ptr, ptr0, len0);\n        return ret === 0 ? undefined : FieldDefinition.__wrap(ret);\n    }\n    /**\n     * @param {string} field_name\n     * @returns {number | undefined}\n     */\n    get_field_index(field_name) {\n        const ptr0 = passStringToWasm0(field_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.jsschema_get_field_index(this.__wbg_ptr, ptr0, len0);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} index\n     * @returns {string | undefined}\n     */\n    get_field_name(index) {\n        const ret = wasm.jsschema_get_field_name(this.__wbg_ptr, index);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * @param {string[]} fields\n     */\n    constructor(fields) {\n        const ptr0 = passArrayJsValueToWasm0(fields, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.jsschema_new(ptr0, len0);\n        return Schema.__wrap(ret);\n    }\n}\nif (Symbol.dispose) JsSchema.prototype[Symbol.dispose] = JsSchema.prototype.free;\n\n/**\n * Error type for Lindera operations.\n */\nclass LinderaError {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(LinderaError.prototype);\n        obj.__wbg_ptr = ptr;\n        LinderaErrorFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        LinderaErrorFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_linderaerror_free(ptr, 0);\n    }\n    /**\n     * @returns {string}\n     */\n    get message() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_linderaerror_message(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @param {string} arg0\n     */\n    set message(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_fielddefinition_name(this.__wbg_ptr, ptr0, len0);\n    }\n}\nif (Symbol.dispose) LinderaError.prototype[Symbol.dispose] = LinderaError.prototype.free;\n\n/**\n * Dictionary metadata configuration.\n */\nclass Metadata {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Metadata.prototype);\n        obj.__wbg_ptr = ptr;\n        MetadataFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        MetadataFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_metadata_free(ptr, 0);\n    }\n}\nif (Symbol.dispose) Metadata.prototype[Symbol.dispose] = Metadata.prototype.free;\n\n/**\n * Tokenization mode.\n *\n * Determines how text is segmented into tokens.\n * @enum {0 | 1}\n */\nconst Mode = Object.freeze({\n    /**\n     * Standard tokenization based on dictionary cost\n     */\n    Normal: 0, \"0\": \"Normal\",\n    /**\n     * Decompose compound words using penalty-based segmentation\n     */\n    Decompose: 1, \"1\": \"Decompose\",\n});\n\n/**\n * Penalty configuration for decompose mode.\n *\n * Controls how aggressively compound words are decomposed based on\n * character type and length thresholds.\n */\nclass Penalty {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Penalty.prototype);\n        obj.__wbg_ptr = ptr;\n        PenaltyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PenaltyFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_penalty_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    get kanji_penalty_length_penalty() {\n        const ret = wasm.__wbg_get_penalty_kanji_penalty_length_penalty(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get kanji_penalty_length_threshold() {\n        const ret = wasm.__wbg_get_penalty_kanji_penalty_length_threshold(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get other_penalty_length_penalty() {\n        const ret = wasm.__wbg_get_penalty_other_penalty_length_penalty(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get other_penalty_length_threshold() {\n        const ret = wasm.__wbg_get_penalty_other_penalty_length_threshold(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} arg0\n     */\n    set kanji_penalty_length_penalty(arg0) {\n        wasm.__wbg_set_penalty_kanji_penalty_length_penalty(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @param {number} arg0\n     */\n    set kanji_penalty_length_threshold(arg0) {\n        wasm.__wbg_set_penalty_kanji_penalty_length_threshold(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @param {number} arg0\n     */\n    set other_penalty_length_penalty(arg0) {\n        wasm.__wbg_set_penalty_other_penalty_length_penalty(this.__wbg_ptr, arg0);\n    }\n    /**\n     * @param {number} arg0\n     */\n    set other_penalty_length_threshold(arg0) {\n        wasm.__wbg_set_penalty_other_penalty_length_threshold(this.__wbg_ptr, arg0);\n    }\n}\nif (Symbol.dispose) Penalty.prototype[Symbol.dispose] = Penalty.prototype.free;\n\n/**\n * Dictionary schema definition.\n */\nclass Schema {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Schema.prototype);\n        obj.__wbg_ptr = ptr;\n        SchemaFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SchemaFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_schema_free(ptr, 0);\n    }\n}\nif (Symbol.dispose) Schema.prototype[Symbol.dispose] = Schema.prototype.free;\n\n/**\n * Core segmenter for morphological analysis.\n */\nclass Segmenter {\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SegmenterFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_segmenter_free(ptr, 0);\n    }\n}\nif (Symbol.dispose) Segmenter.prototype[Symbol.dispose] = Segmenter.prototype.free;\n\n/**\n * Token object wrapping the Rust Token data.\n *\n * This class provides robust access to token field and details.\n */\nclass Token {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Token.prototype);\n        obj.__wbg_ptr = ptr;\n        TokenFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TokenFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_token_free(ptr, 0);\n    }\n    /**\n     * End byte position in the original text.\n     * @returns {number}\n     */\n    get byte_end() {\n        const ret = wasm.__wbg_get_token_byte_end(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Start byte position in the original text.\n     * @returns {number}\n     */\n    get byte_start() {\n        const ret = wasm.__wbg_get_fielddefinition_index(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Morphological details of the token.\n     * @returns {string[]}\n     */\n    get details() {\n        const ret = wasm.__wbg_get_token_details(this.__wbg_ptr);\n        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        return v1;\n    }\n    /**\n     * Whether this token is an unknown word (not found in the dictionary).\n     * @returns {boolean}\n     */\n    get is_unknown() {\n        const ret = wasm.__wbg_get_token_is_unknown(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * Position index of the token.\n     * @returns {number}\n     */\n    get position() {\n        const ret = wasm.__wbg_get_token_position(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Surface form of the token.\n     * @returns {string}\n     */\n    get surface() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.__wbg_get_token_surface(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Word ID in the dictionary.\n     * @returns {number}\n     */\n    get word_id() {\n        const ret = wasm.__wbg_get_token_word_id(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * End byte position in the original text.\n     * @param {number} arg0\n     */\n    set byte_end(arg0) {\n        wasm.__wbg_set_token_byte_end(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Start byte position in the original text.\n     * @param {number} arg0\n     */\n    set byte_start(arg0) {\n        wasm.__wbg_set_fielddefinition_index(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Morphological details of the token.\n     * @param {string[]} arg0\n     */\n    set details(arg0) {\n        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_token_details(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Whether this token is an unknown word (not found in the dictionary).\n     * @param {boolean} arg0\n     */\n    set is_unknown(arg0) {\n        wasm.__wbg_set_token_is_unknown(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Position index of the token.\n     * @param {number} arg0\n     */\n    set position(arg0) {\n        wasm.__wbg_set_token_position(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Surface form of the token.\n     * @param {string} arg0\n     */\n    set surface(arg0) {\n        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.__wbg_set_fielddefinition_name(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n     * Word ID in the dictionary.\n     * @param {number} arg0\n     */\n    set word_id(arg0) {\n        wasm.__wbg_set_token_word_id(this.__wbg_ptr, arg0);\n    }\n    /**\n     * Returns the detail at the specified index.\n     *\n     * # Parameters\n     *\n     * - `index`: Index of the detail to retrieve.\n     *\n     * # Returns\n     *\n     * The detail string if found, otherwise undefined.\n     * @param {number} index\n     * @returns {string | undefined}\n     */\n    getDetail(index) {\n        const ret = wasm.token_getDetail(this.__wbg_ptr, index);\n        let v1;\n        if (ret[0] !== 0) {\n            v1 = getStringFromWasm0(ret[0], ret[1]).slice();\n            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        }\n        return v1;\n    }\n    /**\n     * @returns {any}\n     */\n    toJSON() {\n        const ret = wasm.token_toJSON(this.__wbg_ptr);\n        return ret;\n    }\n}\nif (Symbol.dispose) Token.prototype[Symbol.dispose] = Token.prototype.free;\n\n/**\n * A tokenizer for morphological analysis.\n */\nclass Tokenizer {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Tokenizer.prototype);\n        obj.__wbg_ptr = ptr;\n        TokenizerFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TokenizerFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenizer_free(ptr, 0);\n    }\n    /**\n     * @param {Dictionary} dictionary\n     * @param {string | null} [mode]\n     * @param {UserDictionary | null} [user_dictionary]\n     */\n    constructor(dictionary, mode, user_dictionary) {\n        _assertClass(dictionary, Dictionary);\n        var ptr0 = dictionary.__destroy_into_raw();\n        var ptr1 = isLikeNone(mode) ? 0 : passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        let ptr2 = 0;\n        if (!isLikeNone(user_dictionary)) {\n            _assertClass(user_dictionary, UserDictionary);\n            ptr2 = user_dictionary.__destroy_into_raw();\n        }\n        const ret = wasm.tokenizer_new(ptr0, ptr1, len1, ptr2);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        TokenizerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Tokenizes the input text.\n     * @param {string} input_text\n     * @returns {Token[]}\n     */\n    tokenize(input_text) {\n        const ptr0 = passStringToWasm0(input_text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizer_tokenize(this.__wbg_ptr, ptr0, len0);\n        if (ret[3]) {\n            throw takeFromExternrefTable0(ret[2]);\n        }\n        var v2 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n        return v2;\n    }\n    /**\n     * Tokenizes the input text and returns N-best results.\n     *\n     * Returns an array of arrays, where each inner array contains Token JSON objects.\n     * @param {string} input_text\n     * @param {number} n\n     * @param {boolean | null} [unique]\n     * @param {bigint | null} [cost_threshold]\n     * @returns {any}\n     */\n    tokenizeNbest(input_text, n, unique, cost_threshold) {\n        const ptr0 = passStringToWasm0(input_text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizer_tokenizeNbest(this.__wbg_ptr, ptr0, len0, n, isLikeNone(unique) ? 0xFFFFFF : unique ? 1 : 0, !isLikeNone(cost_threshold), isLikeNone(cost_threshold) ? BigInt(0) : cost_threshold);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * Tokenizes the input text and returns N-best results (snake_case alias).\n     * @param {string} input_text\n     * @param {number} n\n     * @param {boolean | null} [unique]\n     * @param {bigint | null} [cost_threshold]\n     * @returns {any}\n     */\n    tokenize_nbest(input_text, n, unique, cost_threshold) {\n        const ptr0 = passStringToWasm0(input_text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizer_tokenize_nbest(this.__wbg_ptr, ptr0, len0, n, isLikeNone(unique) ? 0xFFFFFF : unique ? 1 : 0, !isLikeNone(cost_threshold), isLikeNone(cost_threshold) ? BigInt(0) : cost_threshold);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n}\nif (Symbol.dispose) Tokenizer.prototype[Symbol.dispose] = Tokenizer.prototype.free;\n\n/**\n * Builder for creating a [`Tokenizer`] instance.\n *\n * `TokenizerBuilder` provides a fluent API for configuring and building a tokenizer\n * with various options such as dictionary selection, tokenization mode, character filters,\n * and token filters.\n */\nclass TokenizerBuilder {\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TokenizerBuilderFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenizerbuilder_free(ptr, 0);\n    }\n    /**\n     * Appends a character filter to the tokenization pipeline.\n     * @param {string} name\n     * @param {any} args\n     */\n    appendCharacterFilter(name, args) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_appendCharacterFilter(this.__wbg_ptr, ptr0, len0, args);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Appends a token filter to the tokenization pipeline.\n     * @param {string} name\n     * @param {any} args\n     */\n    appendTokenFilter(name, args) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_appendTokenFilter(this.__wbg_ptr, ptr0, len0, args);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {string} name\n     * @param {any} args\n     */\n    append_character_filter(name, args) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_append_character_filter(this.__wbg_ptr, ptr0, len0, args);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {string} name\n     * @param {any} args\n     */\n    append_token_filter(name, args) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_append_token_filter(this.__wbg_ptr, ptr0, len0, args);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Builds and returns a configured [`Tokenizer`] instance.\n     * @returns {Tokenizer}\n     */\n    build() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.tokenizerbuilder_build(ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return Tokenizer.__wrap(ret[0]);\n    }\n    /**\n     * Creates a new `TokenizerBuilder` instance.\n     */\n    constructor() {\n        const ret = wasm.tokenizerbuilder_new();\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        TokenizerBuilderFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Sets the dictionary to use for tokenization.\n     * @param {string} uri\n     */\n    setDictionary(uri) {\n        const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_setDictionary(this.__wbg_ptr, ptr0, len0);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Sets whether to keep whitespace tokens in the output.\n     * @param {boolean} keep\n     */\n    setKeepWhitespace(keep) {\n        const ret = wasm.tokenizerbuilder_setKeepWhitespace(this.__wbg_ptr, keep);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Sets the tokenization mode.\n     * @param {string} mode\n     */\n    setMode(mode) {\n        const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_setMode(this.__wbg_ptr, ptr0, len0);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Sets a user-defined dictionary.\n     * @param {string} uri\n     */\n    setUserDictionary(uri) {\n        const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_setUserDictionary(this.__wbg_ptr, ptr0, len0);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {string} uri\n     */\n    set_dictionary(uri) {\n        const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_set_dictionary(this.__wbg_ptr, ptr0, len0);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {boolean} keep\n     */\n    set_keep_whitespace(keep) {\n        const ret = wasm.tokenizerbuilder_set_keep_whitespace(this.__wbg_ptr, keep);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {string} mode\n     */\n    set_mode(mode) {\n        const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_set_mode(this.__wbg_ptr, ptr0, len0);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {string} uri\n     */\n    set_user_dictionary(uri) {\n        const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_set_user_dictionary(this.__wbg_ptr, ptr0, len0);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n}\nif (Symbol.dispose) TokenizerBuilder.prototype[Symbol.dispose] = TokenizerBuilder.prototype.free;\n\n/**\n * A user-defined dictionary for custom words.\n */\nclass UserDictionary {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(UserDictionary.prototype);\n        obj.__wbg_ptr = ptr;\n        UserDictionaryFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        UserDictionaryFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_userdictionary_free(ptr, 0);\n    }\n}\nif (Symbol.dispose) UserDictionary.prototype[Symbol.dispose] = UserDictionary.prototype.free;\n\n/**\n * Builds a dictionary from source files.\n * @param {string} input_dir\n * @param {string} output_dir\n * @param {Metadata} metadata\n */\nfunction buildDictionary(input_dir, output_dir, metadata) {\n    const ptr0 = passStringToWasm0(input_dir, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passStringToWasm0(output_dir, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    _assertClass(metadata, Metadata);\n    var ptr2 = metadata.__destroy_into_raw();\n    const ret = wasm.buildDictionary(ptr0, len0, ptr1, len1, ptr2);\n    if (ret[1]) {\n        throw takeFromExternrefTable0(ret[0]);\n    }\n}\n\n/**\n * Builds a user dictionary from a CSV file.\n * @param {string} input_file\n * @param {string} output_dir\n * @param {Metadata | null} [metadata]\n */\nfunction buildUserDictionary(input_file, output_dir, metadata) {\n    const ptr0 = passStringToWasm0(input_file, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passStringToWasm0(output_dir, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    let ptr2 = 0;\n    if (!isLikeNone(metadata)) {\n        _assertClass(metadata, Metadata);\n        ptr2 = metadata.__destroy_into_raw();\n    }\n    const ret = wasm.buildUserDictionary(ptr0, len0, ptr1, len1, ptr2);\n    if (ret[1]) {\n        throw takeFromExternrefTable0(ret[0]);\n    }\n}\n\n/**\n * @param {string} input_dir\n * @param {string} output_dir\n * @param {Metadata} metadata\n */\nfunction build_dictionary(input_dir, output_dir, metadata) {\n    const ptr0 = passStringToWasm0(input_dir, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passStringToWasm0(output_dir, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    _assertClass(metadata, Metadata);\n    var ptr2 = metadata.__destroy_into_raw();\n    const ret = wasm.build_dictionary(ptr0, len0, ptr1, len1, ptr2);\n    if (ret[1]) {\n        throw takeFromExternrefTable0(ret[0]);\n    }\n}\n\n/**\n * @param {string} input_file\n * @param {string} output_dir\n * @param {Metadata | null} [metadata]\n */\nfunction build_user_dictionary(input_file, output_dir, metadata) {\n    const ptr0 = passStringToWasm0(input_file, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ptr1 = passStringToWasm0(output_dir, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    let ptr2 = 0;\n    if (!isLikeNone(metadata)) {\n        _assertClass(metadata, Metadata);\n        ptr2 = metadata.__destroy_into_raw();\n    }\n    const ret = wasm.build_user_dictionary(ptr0, len0, ptr1, len1, ptr2);\n    if (ret[1]) {\n        throw takeFromExternrefTable0(ret[0]);\n    }\n}\n\n/**\n * Gets the version of the lindera-wasm library.\n * Backward compatibility alias for version().\n * @returns {string}\n */\nfunction getVersion() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const ret = wasm.getVersion();\n        deferred1_0 = ret[0];\n        deferred1_1 = ret[1];\n        return getStringFromWasm0(ret[0], ret[1]);\n    } finally {\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\n/**\n * Loads a dictionary from the specified URI.\n * @param {string} uri\n * @returns {Dictionary}\n */\nfunction loadDictionary(uri) {\n    const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.loadDictionary(ptr0, len0);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return Dictionary.__wrap(ret[0]);\n}\n\n/**\n * Loads a user dictionary from the specified URI.\n * @param {string} uri\n * @param {Metadata} metadata\n * @returns {UserDictionary}\n */\nfunction loadUserDictionary(uri, metadata) {\n    const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    _assertClass(metadata, Metadata);\n    var ptr1 = metadata.__destroy_into_raw();\n    const ret = wasm.loadUserDictionary(ptr0, len0, ptr1);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return UserDictionary.__wrap(ret[0]);\n}\n\n/**\n * @param {string} uri\n * @returns {Dictionary}\n */\nfunction load_dictionary(uri) {\n    const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.load_dictionary(ptr0, len0);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return Dictionary.__wrap(ret[0]);\n}\n\n/**\n * @param {string} uri\n * @param {Metadata} metadata\n * @returns {UserDictionary}\n */\nfunction load_user_dictionary(uri, metadata) {\n    const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    _assertClass(metadata, Metadata);\n    var ptr1 = metadata.__destroy_into_raw();\n    const ret = wasm.load_user_dictionary(ptr0, len0, ptr1);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return UserDictionary.__wrap(ret[0]);\n}\n\n/**\n * Returns the version of the lindera-wasm package.\n * @returns {string}\n */\nfunction version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const ret = wasm.version();\n        deferred1_0 = ret[0];\n        deferred1_1 = ret[1];\n        return getStringFromWasm0(ret[0], ret[1]);\n    } finally {\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction __wbg_get_imports() {\n    const import0 = {\n        __proto__: null,\n        __wbg_Error_8c4e43fe74559d73: function(arg0, arg1) {\n            const ret = Error(getStringFromWasm0(arg0, arg1));\n            return ret;\n        },\n        __wbg_String_8f0eb39a4a4c2f66: function(arg0, arg1) {\n            const ret = String(arg1);\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_bigint_get_as_i64_8fcf4ce7f1ca72a2: function(arg0, arg1) {\n            const v = arg1;\n            const ret = typeof(v) === 'bigint' ? v : undefined;\n            getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n        },\n        __wbg___wbindgen_boolean_get_bbbb1c18aa2f5e25: function(arg0) {\n            const v = arg0;\n            const ret = typeof(v) === 'boolean' ? v : undefined;\n            return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n        },\n        __wbg___wbindgen_debug_string_0bc8482c6e3508ae: function(arg0, arg1) {\n            const ret = debugString(arg1);\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_in_47fa6863be6f2f25: function(arg0, arg1) {\n            const ret = arg0 in arg1;\n            return ret;\n        },\n        __wbg___wbindgen_is_bigint_31b12575b56f32fc: function(arg0) {\n            const ret = typeof(arg0) === 'bigint';\n            return ret;\n        },\n        __wbg___wbindgen_is_function_0095a73b8b156f76: function(arg0) {\n            const ret = typeof(arg0) === 'function';\n            return ret;\n        },\n        __wbg___wbindgen_is_null_ac34f5003991759a: function(arg0) {\n            const ret = arg0 === null;\n            return ret;\n        },\n        __wbg___wbindgen_is_object_5ae8e5880f2c1fbd: function(arg0) {\n            const val = arg0;\n            const ret = typeof(val) === 'object' && val !== null;\n            return ret;\n        },\n        __wbg___wbindgen_is_undefined_9e4d92534c42d778: function(arg0) {\n            const ret = arg0 === undefined;\n            return ret;\n        },\n        __wbg___wbindgen_jsval_eq_11888390b0186270: function(arg0, arg1) {\n            const ret = arg0 === arg1;\n            return ret;\n        },\n        __wbg___wbindgen_jsval_loose_eq_9dd77d8cd6671811: function(arg0, arg1) {\n            const ret = arg0 == arg1;\n            return ret;\n        },\n        __wbg___wbindgen_number_get_8ff4255516ccad3e: function(arg0, arg1) {\n            const obj = arg1;\n            const ret = typeof(obj) === 'number' ? obj : undefined;\n            getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n        },\n        __wbg___wbindgen_string_get_72fb696202c56729: function(arg0, arg1) {\n            const obj = arg1;\n            const ret = typeof(obj) === 'string' ? obj : undefined;\n            var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_throw_be289d5034ed271b: function(arg0, arg1) {\n            throw new Error(getStringFromWasm0(arg0, arg1));\n        },\n        __wbg_call_389efe28435a9388: function() { return handleError(function (arg0, arg1) {\n            const ret = arg0.call(arg1);\n            return ret;\n        }, arguments); },\n        __wbg_done_57b39ecd9addfe81: function(arg0) {\n            const ret = arg0.done;\n            return ret;\n        },\n        __wbg_entries_58c7934c745daac7: function(arg0) {\n            const ret = Object.entries(arg0);\n            return ret;\n        },\n        __wbg_get_9b94d73e6221f75c: function(arg0, arg1) {\n            const ret = arg0[arg1 >>> 0];\n            return ret;\n        },\n        __wbg_get_b3ed3ad4be2bc8ac: function() { return handleError(function (arg0, arg1) {\n            const ret = Reflect.get(arg0, arg1);\n            return ret;\n        }, arguments); },\n        __wbg_instanceof_ArrayBuffer_c367199e2fa2aa04: function(arg0) {\n            let result;\n            try {\n                result = arg0 instanceof ArrayBuffer;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_instanceof_Map_53af74335dec57f4: function(arg0) {\n            let result;\n            try {\n                result = arg0 instanceof Map;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_instanceof_Uint8Array_9b9075935c74707c: function(arg0) {\n            let result;\n            try {\n                result = arg0 instanceof Uint8Array;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_isArray_d314bb98fcf08331: function(arg0) {\n            const ret = Array.isArray(arg0);\n            return ret;\n        },\n        __wbg_isSafeInteger_bfbc7332a9768d2a: function(arg0) {\n            const ret = Number.isSafeInteger(arg0);\n            return ret;\n        },\n        __wbg_iterator_6ff6560ca1568e55: function() {\n            const ret = Symbol.iterator;\n            return ret;\n        },\n        __wbg_length_32ed9a279acd054c: function(arg0) {\n            const ret = arg0.length;\n            return ret;\n        },\n        __wbg_length_35a7bace40f36eac: function(arg0) {\n            const ret = arg0.length;\n            return ret;\n        },\n        __wbg_new_361308b2356cecd0: function() {\n            const ret = new Object();\n            return ret;\n        },\n        __wbg_new_3eb36ae241fe6f44: function() {\n            const ret = new Array();\n            return ret;\n        },\n        __wbg_new_dd2b680c8bf6ae29: function(arg0) {\n            const ret = new Uint8Array(arg0);\n            return ret;\n        },\n        __wbg_next_3482f54c49e8af19: function() { return handleError(function (arg0) {\n            const ret = arg0.next();\n            return ret;\n        }, arguments); },\n        __wbg_next_418f80d8f5303233: function(arg0) {\n            const ret = arg0.next;\n            return ret;\n        },\n        __wbg_prototypesetcall_bdcdcc5842e4d77d: function(arg0, arg1, arg2) {\n            Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), arg2);\n        },\n        __wbg_push_8ffdcb2063340ba5: function(arg0, arg1) {\n            const ret = arg0.push(arg1);\n            return ret;\n        },\n        __wbg_set_6cb8631f80447a67: function() { return handleError(function (arg0, arg1, arg2) {\n            const ret = Reflect.set(arg0, arg1, arg2);\n            return ret;\n        }, arguments); },\n        __wbg_token_new: function(arg0) {\n            const ret = Token.__wrap(arg0);\n            return ret;\n        },\n        __wbg_value_0546255b415e96c1: function(arg0) {\n            const ret = arg0.value;\n            return ret;\n        },\n        __wbindgen_cast_0000000000000001: function(arg0) {\n            // Cast intrinsic for `F64 -> Externref`.\n            const ret = arg0;\n            return ret;\n        },\n        __wbindgen_cast_0000000000000002: function(arg0) {\n            // Cast intrinsic for `I64 -> Externref`.\n            const ret = arg0;\n            return ret;\n        },\n        __wbindgen_cast_0000000000000003: function(arg0, arg1) {\n            // Cast intrinsic for `Ref(String) -> Externref`.\n            const ret = getStringFromWasm0(arg0, arg1);\n            return ret;\n        },\n        __wbindgen_cast_0000000000000004: function(arg0) {\n            // Cast intrinsic for `U64 -> Externref`.\n            const ret = BigInt.asUintN(64, arg0);\n            return ret;\n        },\n        __wbindgen_init_externref_table: function() {\n            const table = wasm.__wbindgen_externrefs;\n            const offset = table.grow(4);\n            table.set(0, undefined);\n            table.set(offset + 0, undefined);\n            table.set(offset + 1, null);\n            table.set(offset + 2, true);\n            table.set(offset + 3, false);\n        },\n    };\n    return {\n        __proto__: null,\n        \"./lindera_wasm_bg.js\": import0,\n    };\n}\n\nconst DictionaryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_dictionary_free(ptr >>> 0, 1));\nconst FieldDefinitionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_fielddefinition_free(ptr >>> 0, 1));\nconst JsDictionaryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsdictionary_free(ptr >>> 0, 1));\nconst JsFieldDefinitionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsfielddefinition_free(ptr >>> 0, 1));\nconst JsLinderaErrorFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jslinderaerror_free(ptr >>> 0, 1));\nconst JsMetadataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsmetadata_free(ptr >>> 0, 1));\nconst JsPenaltyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jspenalty_free(ptr >>> 0, 1));\nconst JsSchemaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_jsschema_free(ptr >>> 0, 1));\nconst LinderaErrorFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_linderaerror_free(ptr >>> 0, 1));\nconst MetadataFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_metadata_free(ptr >>> 0, 1));\nconst PenaltyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_penalty_free(ptr >>> 0, 1));\nconst SchemaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_schema_free(ptr >>> 0, 1));\nconst SegmenterFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_segmenter_free(ptr >>> 0, 1));\nconst TokenFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_token_free(ptr >>> 0, 1));\nconst TokenizerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_tokenizer_free(ptr >>> 0, 1));\nconst TokenizerBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_tokenizerbuilder_free(ptr >>> 0, 1));\nconst UserDictionaryFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_userdictionary_free(ptr >>> 0, 1));\n\nfunction addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_externrefs.set(idx, obj);\n    return idx;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction getArrayJsValueFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    const mem = getDataViewMemory0();\n    const result = [];\n    for (let i = ptr; i < ptr + 4 * len; i += 4) {\n        result.push(wasm.__wbindgen_externrefs.get(mem.getUint32(i, true)));\n    }\n    wasm.__externref_drop_slice(ptr, len);\n    return result;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedDataViewMemory0 = null;\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return decodeText(ptr, len);\n}\n\nlet cachedUint8ArrayMemory0 = null;\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        const idx = addToExternrefTable0(e);\n        wasm.__wbindgen_exn_store(idx);\n    }\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4, 4) >>> 0;\n    for (let i = 0; i < array.length; i++) {\n        const add = addToExternrefTable0(array[i]);\n        getDataViewMemory0().setUint32(ptr + 4 * i, add, true);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = cachedTextEncoder.encodeInto(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_externrefs.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\ncachedTextDecoder.decode();\nconst MAX_SAFARI_DECODE_BYTES = 2146435072;\nlet numBytesDecoded = 0;\nfunction decodeText(ptr, len) {\n    numBytesDecoded += len;\n    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {\n        cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n        cachedTextDecoder.decode();\n        numBytesDecoded = len;\n    }\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nconst cachedTextEncoder = new TextEncoder();\n\nif (!('encodeInto' in cachedTextEncoder)) {\n    cachedTextEncoder.encodeInto = function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n            read: arg.length,\n            written: buf.length\n        };\n    };\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet wasmModule, wasm;\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    wasmModule = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n            } catch (e) {\n                const validResponse = module.ok && expectedResponseType(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else { throw e; }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n        } else {\n            return instance;\n        }\n    }\n\n    function expectedResponseType(type) {\n        switch (type) {\n            case 'basic': case 'cors': case 'default': return true;\n        }\n        return false;\n    }\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (module !== undefined) {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n    const instance = new WebAssembly.Instance(module, imports);\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (module_or_path !== undefined) {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (module_or_path === undefined) {\n        module_or_path = new URL(/* asset import */ __webpack_require__(/*! lindera_wasm_bg.wasm */ \"../pkg/lindera_wasm_bg.wasm\"), __webpack_require__.b);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\n\n\n\n//# sourceURL=webpack://lindera-wasm-example/../pkg/lindera_wasm.js?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "./";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = (typeof document !== 'undefined' && document.baseURI) || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;