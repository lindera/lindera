/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../pkg/lindera_wasm.js"
/*!******************************!*\
  !*** ../pkg/lindera_wasm.js ***!
  \******************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tokenizer: () => (/* binding */ Tokenizer),\n/* harmony export */   TokenizerBuilder: () => (/* binding */ TokenizerBuilder),\n/* harmony export */   \"default\": () => (/* binding */ __wbg_init),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   initSync: () => (/* binding */ initSync)\n/* harmony export */ });\n/* @ts-self-types=\"./lindera_wasm.d.ts\" */\n\n/**\n * A tokenizer for morphological analysis.\n *\n * The `Tokenizer` performs text tokenization based on the configuration\n * provided by [`TokenizerBuilder`].\n *\n * # Examples\n *\n * ```javascript\n * const builder = new TokenizerBuilder();\n * builder.setDictionary(\"embedded://ipadic\");\n * builder.setMode(\"normal\");\n *\n * const tokenizer = builder.build();\n * const tokens = tokenizer.tokenize(\"関西国際空港\");\n * console.log(tokens);\n * // Output: [\n * //   { surface: \"関西国際空港\", ... },\n * //   ...\n * // ]\n * ```\n */\nclass Tokenizer {\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Tokenizer.prototype);\n        obj.__wbg_ptr = ptr;\n        TokenizerFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TokenizerFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenizer_free(ptr, 0);\n    }\n    /**\n     * Tokenizes the input text.\n     *\n     * Analyzes the input text and returns an array of token objects. Each token\n     * contains information such as surface form, part-of-speech tags, reading, etc.\n     * Field names in the returned objects are in camelCase.\n     *\n     * # Parameters\n     *\n     * - `input_text`: The text to tokenize.\n     *\n     * # Returns\n     *\n     * A JavaScript array of token objects. Each token object contains:\n     * - `surface`: The surface form of the token\n     * - `pos`: Part-of-speech tags\n     * - Additional language-specific fields\n     *\n     * # Errors\n     *\n     * Returns an error if tokenization fails.\n     *\n     * # Examples\n     *\n     * ```javascript\n     * const tokens = tokenizer.tokenize(\"東京都に行く\");\n     * tokens.forEach(token => {\n     *     console.log(token.surface, token.pos);\n     * });\n     * ```\n     * @param {string} input_text\n     * @returns {any}\n     */\n    tokenize(input_text) {\n        const ptr0 = passStringToWasm0(input_text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizer_tokenize(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n}\nif (Symbol.dispose) Tokenizer.prototype[Symbol.dispose] = Tokenizer.prototype.free;\n\n/**\n * Builder for creating a [`Tokenizer`] instance.\n *\n * `TokenizerBuilder` provides a fluent API for configuring and building a tokenizer\n * with various options such as dictionary selection, tokenization mode, character filters,\n * and token filters.\n *\n * # Examples\n *\n * ```javascript\n * const builder = new TokenizerBuilder();\n * builder.setDictionary(\"embedded://ipadic\");\n * builder.setMode(\"normal\");\n * builder.setKeepWhitespace(false);\n * builder.appendCharacterFilter(\"unicode_normalize\", { \"kind\": \"nfkc\" });\n * builder.appendTokenFilter(\"lowercase\");\n *\n * const tokenizer = builder.build();\n * ```\n */\nclass TokenizerBuilder {\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        TokenizerBuilderFinalization.unregister(this);\n        return ptr;\n    }\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tokenizerbuilder_free(ptr, 0);\n    }\n    /**\n     * Appends a character filter to the tokenization pipeline.\n     *\n     * Character filters transform the input text before tokenization.\n     *\n     * # Parameters\n     *\n     * - `name`: The name of the character filter (e.g., `\"unicode_normalize\"`).\n     * - `args`: A JavaScript object containing filter-specific arguments.\n     *\n     * # Errors\n     *\n     * Returns an error if the arguments cannot be parsed.\n     *\n     * # Examples\n     *\n     * ```javascript\n     * builder.appendCharacterFilter(\"unicode_normalize\", { \"kind\": \"nfkc\" });\n     * ```\n     * @param {string} name\n     * @param {any} args\n     */\n    appendCharacterFilter(name, args) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_appendCharacterFilter(this.__wbg_ptr, ptr0, len0, args);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Appends a token filter to the tokenization pipeline.\n     *\n     * Token filters transform or filter the tokens after tokenization.\n     *\n     * # Parameters\n     *\n     * - `name`: The name of the token filter (e.g., `\"lowercase\"`, `\"japanese_number\"`).\n     * - `args`: A JavaScript object containing filter-specific arguments.\n     *\n     * # Errors\n     *\n     * Returns an error if the arguments cannot be parsed.\n     *\n     * # Examples\n     *\n     * ```javascript\n     * builder.appendTokenFilter(\"lowercase\");\n     * builder.appendTokenFilter(\"japanese_number\", { \"tags\": [\"名詞,数\"] });\n     * ```\n     * @param {string} name\n     * @param {any} args\n     */\n    appendTokenFilter(name, args) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_appendTokenFilter(this.__wbg_ptr, ptr0, len0, args);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Builds and returns a configured [`Tokenizer`] instance.\n     *\n     * This method consumes the builder and creates the final tokenizer with all\n     * configured settings.\n     *\n     * # Returns\n     *\n     * A configured `Tokenizer` instance.\n     *\n     * # Errors\n     *\n     * Returns an error if the tokenizer cannot be built with the current configuration.\n     *\n     * # Examples\n     *\n     * ```javascript\n     * const builder = new TokenizerBuilder();\n     * builder.setDictionary(\"embedded://ipadic\");\n     * const tokenizer = builder.build();\n     * ```\n     * @returns {Tokenizer}\n     */\n    build() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.tokenizerbuilder_build(ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return Tokenizer.__wrap(ret[0]);\n    }\n    /**\n     * Creates a new `TokenizerBuilder` instance.\n     *\n     * # Returns\n     *\n     * A new `TokenizerBuilder` instance.\n     *\n     * # Errors\n     *\n     * Returns an error if the builder cannot be initialized.\n     *\n     * # Examples\n     *\n     * ```javascript\n     * const builder = new TokenizerBuilder();\n     * ```\n     */\n    constructor() {\n        const ret = wasm.tokenizerbuilder_new();\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        this.__wbg_ptr = ret[0] >>> 0;\n        TokenizerBuilderFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Sets the dictionary to use for tokenization.\n     *\n     * # Parameters\n     *\n     * - `uri`: The dictionary URI. Valid embedded dictionaries are:\n     *   - `\"embedded://ipadic\"`: Japanese IPADIC dictionary\n     *   - `\"embedded://unidic\"`: Japanese UniDic dictionary\n     *   - `\"embedded://ko-dic\"`: Korean ko-dic dictionary\n     *   - `\"embedded://cc-cedict\"`: Chinese CC-CEDICT dictionary\n     *\n     * # Examples\n     *\n     * ```javascript\n     * builder.setDictionary(\"embedded://ipadic\");\n     * ```\n     * @param {string} uri\n     */\n    setDictionary(uri) {\n        const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_setDictionary(this.__wbg_ptr, ptr0, len0);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Sets whether to keep whitespace tokens in the output.\n     *\n     * # Parameters\n     *\n     * - `keep`: If `true`, whitespace tokens are preserved; if `false`, they are removed.\n     *\n     * # Examples\n     *\n     * ```javascript\n     * builder.setKeepWhitespace(false); // Remove whitespace tokens\n     * // or\n     * builder.setKeepWhitespace(true);  // Keep whitespace tokens\n     * ```\n     * @param {boolean} keep\n     */\n    setKeepWhitespace(keep) {\n        const ret = wasm.tokenizerbuilder_setKeepWhitespace(this.__wbg_ptr, keep);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Sets the tokenization mode.\n     *\n     * # Parameters\n     *\n     * - `mode`: The tokenization mode. Valid values are:\n     *   - `\"normal\"`: Standard tokenization\n     *   - `\"decompose\"`: Decomposes compound words into their components\n     *\n     * # Errors\n     *\n     * Returns an error if the mode string is invalid.\n     *\n     * # Examples\n     *\n     * ```javascript\n     * builder.setMode(\"normal\");\n     * // or\n     * builder.setMode(\"decompose\");\n     * ```\n     * @param {string} mode\n     */\n    setMode(mode) {\n        const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_setMode(this.__wbg_ptr, ptr0, len0);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * Sets a user-defined dictionary.\n     *\n     * User dictionaries allow you to add custom words and their properties\n     * to supplement the main dictionary.\n     *\n     * # Parameters\n     *\n     * - `uri`: The URI to the user dictionary file.\n     *\n     * # Examples\n     *\n     * ```javascript\n     * builder.setUserDictionary(\"path/to/user_dict.csv\");\n     * ```\n     * @param {string} uri\n     */\n    setUserDictionary(uri) {\n        const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.tokenizerbuilder_setUserDictionary(this.__wbg_ptr, ptr0, len0);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n}\nif (Symbol.dispose) TokenizerBuilder.prototype[Symbol.dispose] = TokenizerBuilder.prototype.free;\n\n/**\n * Gets the version of the lindera-wasm library.\n *\n * # Returns\n *\n * The version string of the library (e.g., \"1.0.0\").\n *\n * # Examples\n *\n * ```javascript\n * import { getVersion } from 'lindera-wasm';\n * console.log(getVersion()); // \"1.0.0\"\n * ```\n * @returns {string}\n */\nfunction getVersion() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const ret = wasm.getVersion();\n        deferred1_0 = ret[0];\n        deferred1_1 = ret[1];\n        return getStringFromWasm0(ret[0], ret[1]);\n    } finally {\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction __wbg_get_imports() {\n    const import0 = {\n        __proto__: null,\n        __wbg_Error_8c4e43fe74559d73: function(arg0, arg1) {\n            const ret = Error(getStringFromWasm0(arg0, arg1));\n            return ret;\n        },\n        __wbg_String_8f0eb39a4a4c2f66: function(arg0, arg1) {\n            const ret = String(arg1);\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_bigint_get_as_i64_8fcf4ce7f1ca72a2: function(arg0, arg1) {\n            const v = arg1;\n            const ret = typeof(v) === 'bigint' ? v : undefined;\n            getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n        },\n        __wbg___wbindgen_boolean_get_bbbb1c18aa2f5e25: function(arg0) {\n            const v = arg0;\n            const ret = typeof(v) === 'boolean' ? v : undefined;\n            return isLikeNone(ret) ? 0xFFFFFF : ret ? 1 : 0;\n        },\n        __wbg___wbindgen_debug_string_0bc8482c6e3508ae: function(arg0, arg1) {\n            const ret = debugString(arg1);\n            const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_in_47fa6863be6f2f25: function(arg0, arg1) {\n            const ret = arg0 in arg1;\n            return ret;\n        },\n        __wbg___wbindgen_is_bigint_31b12575b56f32fc: function(arg0) {\n            const ret = typeof(arg0) === 'bigint';\n            return ret;\n        },\n        __wbg___wbindgen_is_function_0095a73b8b156f76: function(arg0) {\n            const ret = typeof(arg0) === 'function';\n            return ret;\n        },\n        __wbg___wbindgen_is_object_5ae8e5880f2c1fbd: function(arg0) {\n            const val = arg0;\n            const ret = typeof(val) === 'object' && val !== null;\n            return ret;\n        },\n        __wbg___wbindgen_jsval_eq_11888390b0186270: function(arg0, arg1) {\n            const ret = arg0 === arg1;\n            return ret;\n        },\n        __wbg___wbindgen_jsval_loose_eq_9dd77d8cd6671811: function(arg0, arg1) {\n            const ret = arg0 == arg1;\n            return ret;\n        },\n        __wbg___wbindgen_number_get_8ff4255516ccad3e: function(arg0, arg1) {\n            const obj = arg1;\n            const ret = typeof(obj) === 'number' ? obj : undefined;\n            getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n        },\n        __wbg___wbindgen_string_get_72fb696202c56729: function(arg0, arg1) {\n            const obj = arg1;\n            const ret = typeof(obj) === 'string' ? obj : undefined;\n            var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len1 = WASM_VECTOR_LEN;\n            getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n            getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n        },\n        __wbg___wbindgen_throw_be289d5034ed271b: function(arg0, arg1) {\n            throw new Error(getStringFromWasm0(arg0, arg1));\n        },\n        __wbg_call_389efe28435a9388: function() { return handleError(function (arg0, arg1) {\n            const ret = arg0.call(arg1);\n            return ret;\n        }, arguments); },\n        __wbg_done_57b39ecd9addfe81: function(arg0) {\n            const ret = arg0.done;\n            return ret;\n        },\n        __wbg_entries_58c7934c745daac7: function(arg0) {\n            const ret = Object.entries(arg0);\n            return ret;\n        },\n        __wbg_get_9b94d73e6221f75c: function(arg0, arg1) {\n            const ret = arg0[arg1 >>> 0];\n            return ret;\n        },\n        __wbg_get_b3ed3ad4be2bc8ac: function() { return handleError(function (arg0, arg1) {\n            const ret = Reflect.get(arg0, arg1);\n            return ret;\n        }, arguments); },\n        __wbg_instanceof_ArrayBuffer_c367199e2fa2aa04: function(arg0) {\n            let result;\n            try {\n                result = arg0 instanceof ArrayBuffer;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_instanceof_Map_53af74335dec57f4: function(arg0) {\n            let result;\n            try {\n                result = arg0 instanceof Map;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_instanceof_Uint8Array_9b9075935c74707c: function(arg0) {\n            let result;\n            try {\n                result = arg0 instanceof Uint8Array;\n            } catch (_) {\n                result = false;\n            }\n            const ret = result;\n            return ret;\n        },\n        __wbg_isArray_d314bb98fcf08331: function(arg0) {\n            const ret = Array.isArray(arg0);\n            return ret;\n        },\n        __wbg_isSafeInteger_bfbc7332a9768d2a: function(arg0) {\n            const ret = Number.isSafeInteger(arg0);\n            return ret;\n        },\n        __wbg_iterator_6ff6560ca1568e55: function() {\n            const ret = Symbol.iterator;\n            return ret;\n        },\n        __wbg_length_32ed9a279acd054c: function(arg0) {\n            const ret = arg0.length;\n            return ret;\n        },\n        __wbg_length_35a7bace40f36eac: function(arg0) {\n            const ret = arg0.length;\n            return ret;\n        },\n        __wbg_new_361308b2356cecd0: function() {\n            const ret = new Object();\n            return ret;\n        },\n        __wbg_new_3eb36ae241fe6f44: function() {\n            const ret = new Array();\n            return ret;\n        },\n        __wbg_new_dd2b680c8bf6ae29: function(arg0) {\n            const ret = new Uint8Array(arg0);\n            return ret;\n        },\n        __wbg_next_3482f54c49e8af19: function() { return handleError(function (arg0) {\n            const ret = arg0.next();\n            return ret;\n        }, arguments); },\n        __wbg_next_418f80d8f5303233: function(arg0) {\n            const ret = arg0.next;\n            return ret;\n        },\n        __wbg_prototypesetcall_bdcdcc5842e4d77d: function(arg0, arg1, arg2) {\n            Uint8Array.prototype.set.call(getArrayU8FromWasm0(arg0, arg1), arg2);\n        },\n        __wbg_push_8ffdcb2063340ba5: function(arg0, arg1) {\n            const ret = arg0.push(arg1);\n            return ret;\n        },\n        __wbg_set_6cb8631f80447a67: function() { return handleError(function (arg0, arg1, arg2) {\n            const ret = Reflect.set(arg0, arg1, arg2);\n            return ret;\n        }, arguments); },\n        __wbg_value_0546255b415e96c1: function(arg0) {\n            const ret = arg0.value;\n            return ret;\n        },\n        __wbindgen_cast_0000000000000001: function(arg0) {\n            // Cast intrinsic for `F64 -> Externref`.\n            const ret = arg0;\n            return ret;\n        },\n        __wbindgen_cast_0000000000000002: function(arg0) {\n            // Cast intrinsic for `I64 -> Externref`.\n            const ret = arg0;\n            return ret;\n        },\n        __wbindgen_cast_0000000000000003: function(arg0, arg1) {\n            // Cast intrinsic for `Ref(String) -> Externref`.\n            const ret = getStringFromWasm0(arg0, arg1);\n            return ret;\n        },\n        __wbindgen_cast_0000000000000004: function(arg0) {\n            // Cast intrinsic for `U64 -> Externref`.\n            const ret = BigInt.asUintN(64, arg0);\n            return ret;\n        },\n        __wbindgen_init_externref_table: function() {\n            const table = wasm.__wbindgen_externrefs;\n            const offset = table.grow(4);\n            table.set(0, undefined);\n            table.set(offset + 0, undefined);\n            table.set(offset + 1, null);\n            table.set(offset + 2, true);\n            table.set(offset + 3, false);\n        },\n    };\n    return {\n        __proto__: null,\n        \"./lindera_wasm_bg.js\": import0,\n    };\n}\n\nconst TokenizerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_tokenizer_free(ptr >>> 0, 1));\nconst TokenizerBuilderFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_tokenizerbuilder_free(ptr >>> 0, 1));\n\nfunction addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_externrefs.set(idx, obj);\n    return idx;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet cachedDataViewMemory0 = null;\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return decodeText(ptr, len);\n}\n\nlet cachedUint8ArrayMemory0 = null;\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        const idx = addToExternrefTable0(e);\n        wasm.__wbindgen_exn_store(idx);\n    }\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = cachedTextEncoder.encodeInto(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_externrefs.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\ncachedTextDecoder.decode();\nconst MAX_SAFARI_DECODE_BYTES = 2146435072;\nlet numBytesDecoded = 0;\nfunction decodeText(ptr, len) {\n    numBytesDecoded += len;\n    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {\n        cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n        cachedTextDecoder.decode();\n        numBytesDecoded = len;\n    }\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nconst cachedTextEncoder = new TextEncoder();\n\nif (!('encodeInto' in cachedTextEncoder)) {\n    cachedTextEncoder.encodeInto = function (arg, view) {\n        const buf = cachedTextEncoder.encode(arg);\n        view.set(buf);\n        return {\n            read: arg.length,\n            written: buf.length\n        };\n    };\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet wasmModule, wasm;\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    wasmModule = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n            } catch (e) {\n                const validResponse = module.ok && expectedResponseType(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else { throw e; }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n        } else {\n            return instance;\n        }\n    }\n\n    function expectedResponseType(type) {\n        switch (type) {\n            case 'basic': case 'cors': case 'default': return true;\n        }\n        return false;\n    }\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (module !== undefined) {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n    const instance = new WebAssembly.Instance(module, imports);\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (module_or_path !== undefined) {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (module_or_path === undefined) {\n        module_or_path = new URL(/* asset import */ __webpack_require__(/*! lindera_wasm_bg.wasm */ \"../pkg/lindera_wasm_bg.wasm\"), __webpack_require__.b);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\n\n\n\n//# sourceURL=webpack://lindera-wasm-example/../pkg/lindera_wasm.js?\n}");

/***/ },

/***/ "../pkg/lindera_wasm_bg.wasm"
/*!***********************************!*\
  !*** ../pkg/lindera_wasm_bg.wasm ***!
  \***********************************/
(module, __unused_webpack_exports, __webpack_require__) {

eval("{module.exports = __webpack_require__.p + \"0d7919f5b8bf322c70bd.wasm\";\n\n//# sourceURL=webpack://lindera-wasm-example/../pkg/lindera_wasm_bg.wasm?\n}");

/***/ },

/***/ "./src/index.js"
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pkg_lindera_wasm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../pkg/lindera_wasm.js */ \"../pkg/lindera_wasm.js\");\n\n\n// Initialize the tokenizer\nlet tokenizer = null;\n\n// Initialize WASM module first\n(0,_pkg_lindera_wasm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().then(() => {\n    // Show the version in the title\n    try {\n        const version = (0,_pkg_lindera_wasm_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)();\n        document.title = `Lindera WASM v${version}`;\n        document.getElementById('title').textContent = `Lindera WASM v${version}`;\n    } catch (e) {\n        console.error(\"Failed to get version:\", e);\n    }\n\n    try {\n        // Create a TokenizerBuilder instance\n        let builder = new _pkg_lindera_wasm_js__WEBPACK_IMPORTED_MODULE_0__.TokenizerBuilder();\n        // Set the dictionary to \"ipadic\" (Japanese)\n        // You can also use \"ko-dic\" (Korean) or \"cc-cedict\" (Chinese) as the dictionary\n        builder.setDictionary(\"embedded://ipadic\");\n\n        // Set the tokenizer mode to \"normal\"\n        // You can also use \"decompose\" for decomposing the compound words into their components\n        builder.setMode(\"normal\");\n\n        // Set to not keep whitespace tokens\n        // You can set it to true if you want to keep whitespace tokens\n        builder.setKeepWhitespace(false);\n\n        // Append character filters\n        builder.appendCharacterFilter(\"unicode_normalize\", { \"kind\": \"nfkc\" });\n\n        // Append token filters\n        builder.appendTokenFilter(\"lowercase\");\n        builder.appendTokenFilter(\"japanese_compound_word\", {\n            \"kind\": \"ipadic\",\n            \"tags\": [\n                \"名詞,数\"\n            ],\n            \"new_tag\": \"名詞,数\"\n        });\n        builder.appendTokenFilter(\"japanese_number\", { \"tags\": [\"名詞,数\"] });\n\n        // Build the Tokenizer instance\n        tokenizer = builder.build();\n\n        console.log(\"Tokenizer is ready.\");\n    } catch (e) {\n        // Handle the error\n        console.error(\"Failed to create Tokenizer:\", e);\n    }\n}).catch(e => {\n    console.error(\"Failed to initialize WASM module:\", e);\n});\n\n// Add an event listener to the \"runButton\" element\ndocument.getElementById('runButton').addEventListener('click', () => {\n    // If the tokenizer is not initialized yet, display an error message\n    if (!tokenizer) {\n        console.error(\"Tokenizer is not initialized yet.\");\n        return;\n    }\n\n    // Get the input text from the \"inputText\" element\n    const inputText = document.getElementById('inputText').value;\n\n    // Tokenize the input text\n    const tokens = tokenizer.tokenize(inputText);\n\n    // Get the \"resultList\" element\n    const resultList = document.getElementById('resultList');\n\n    // Clear the previous results\n    resultList.innerHTML = '';\n\n    // Display the tokens\n    console.log('All tokens:', tokens); // Log the entire tokens array\n\n    tokens.forEach((token, index) => {\n        const li = document.createElement('li');\n        const pre = document.createElement('pre');\n\n        console.log(`Token ${index}:`, token); // Log each individual token object\n\n        pre.textContent = JSON.stringify(token, null, 2);\n        li.appendChild(pre);\n\n        resultList.appendChild(li);\n    });\n});\n\n\n//# sourceURL=webpack://lindera-wasm-example/./src/index.js?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/lindera-wasm/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = (typeof document !== 'undefined' && document.baseURI) || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;